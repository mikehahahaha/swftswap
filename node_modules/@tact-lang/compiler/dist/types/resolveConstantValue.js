"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.resolveConstantValue = void 0;
const core_1 = require("@ton/core");
const features_1 = require("../config/features");
const ast_1 = require("../grammar/ast");
const types_1 = require("./types");
const crypto_1 = require("@ton/crypto");
function reduceIntImpl(ast) {
    if (ast.kind === "number") {
        return ast.value;
    }
    else if (ast.kind === "op_binary") {
        const l = reduceInt(ast.left);
        const r = reduceInt(ast.right);
        if (ast.op === "+") {
            return l + r;
        }
        else if (ast.op === "-") {
            return l - r;
        }
        else if (ast.op === "*") {
            return l * r;
        }
        else if (ast.op === "/") {
            return l / r;
        }
        else if (ast.op === "%") {
            return l % r;
        }
        else if (ast.op === "<<") {
            return l << r;
        }
        else if (ast.op === ">>") {
            return l >> r;
        }
        else if (ast.op === "&") {
            return l & r;
        }
        else if (ast.op === "|") {
            return l | r;
        }
        else if (ast.op === "^") {
            return l ^ r;
        }
    }
    else if (ast.kind === "op_unary") {
        if (ast.op === "-") {
            return -reduceInt(ast.right);
        }
        else if (ast.op === "+") {
            return reduceInt(ast.right);
        }
    }
    else if (ast.kind === "op_static_call") {
        if (ast.name === "ton") {
            if (ast.args.length === 1) {
                return BigInt((0, core_1.toNano)(reduceString(ast.args[0])).toString(10));
            }
        }
        if (ast.name === "pow") {
            if (ast.args.length === 2) {
                return reduceInt(ast.args[0]) ** reduceInt(ast.args[1]);
            }
        }
        if (ast.name === "pow2") {
            if (ast.args.length === 1) {
                return 2n ** reduceInt(ast.args[0]);
            }
        }
        if (ast.name === "sha256") {
            if (ast.args.length === 1 && ast.args[0].kind === "string") {
                const str = reduceString(ast.args[0]);
                if (Buffer.from(str).length <= 128) {
                    return BigInt("0x" + (0, crypto_1.sha256_sync)(str).toString("hex"));
                }
            }
        }
    }
    (0, ast_1.throwError)("Cannot reduce expression to a constant integer", ast.ref);
}
function reduceInt(ast) {
    try {
        return reduceIntImpl(ast);
    }
    catch (error) {
        if (error instanceof RangeError) {
            (0, ast_1.throwError)("Cannot evaluate constant expression due to integer overflow", ast.ref);
        }
        else {
            throw error;
        }
    }
}
function reduceBool(ast) {
    if (ast.kind === "boolean") {
        return ast.value;
    }
    if (ast.kind === "op_unary") {
        if (ast.op === "!") {
            return !reduceBool(ast.right);
        }
    }
    if (ast.kind === "op_binary") {
        if (ast.op === "&&") {
            return reduceBool(ast.left) && reduceBool(ast.right);
        }
        else if (ast.op === "||") {
            return reduceBool(ast.left) || reduceBool(ast.right);
        }
        // TODO: More cases
    }
    (0, ast_1.throwError)("Cannot reduce expression to a constant boolean", ast.ref);
}
function reduceString(ast) {
    if (ast.kind === "string") {
        return ast.value;
    }
    (0, ast_1.throwError)("Cannot reduce expression to a constant string", ast.ref);
}
function reduceAddress(ast, ctx) {
    if (ast.kind === "op_static_call") {
        if (ast.name === "address") {
            if (ast.args.length === 1) {
                const str = reduceString(ast.args[0]);
                const address = core_1.Address.parse(str);
                if (address.workChain !== 0 && address.workChain !== -1) {
                    (0, ast_1.throwError)(`Address ${str} invalid address`, ast.ref);
                }
                if (!(0, features_1.enabledMasterchain)(ctx)) {
                    if (address.workChain !== 0) {
                        (0, ast_1.throwError)(`Address ${str} from masterchain are not enabled for this contract`, ast.ref);
                    }
                }
                return address;
            }
        }
        else if (ast.name === "newAddress") {
            if (ast.args.length === 2) {
                const wc = reduceInt(ast.args[0]);
                const addr = Buffer.from(reduceInt(ast.args[1]).toString(16), "hex");
                if (wc !== 0n && wc !== -1n) {
                    (0, ast_1.throwError)(`Expected workchain to equal 0 or -1, received: ${wc}`, ast.ref);
                }
                if (!(0, features_1.enabledMasterchain)(ctx)) {
                    if (wc !== 0n) {
                        (0, ast_1.throwError)(`Address ${wc}:${addr} from masterchain are not enabled for this contract`, ast.ref);
                    }
                }
                return new core_1.Address(parseInt(wc.toString()), addr);
            }
        }
    }
    (0, ast_1.throwError)("Cannot reduce expression to a constant Address", ast.ref);
}
function reduceCell(ast) {
    if (ast.kind === "op_static_call") {
        if (ast.name === "cell") {
            if (ast.args.length === 1) {
                const str = reduceString(ast.args[0]);
                let c;
                try {
                    c = core_1.Cell.fromBase64(str);
                }
                catch (e) {
                    (0, ast_1.throwError)(`Invalid cell ${str}`, ast.ref);
                }
                return c;
            }
        }
    }
    (0, ast_1.throwError)("Cannot reduce expression to a constant Cell", ast.ref);
}
function resolveConstantValue(type, ast, ctx) {
    if (ast === null) {
        return undefined;
    }
    if (type.kind !== "ref") {
        (0, ast_1.throwError)(`Expected constant value, got ${(0, types_1.printTypeRef)(type)}`, ast.ref);
    }
    // Handle optional
    if (type.optional) {
        if (ast.kind === "null") {
            return null;
        }
    }
    // Handle int
    if (type.name === "Int") {
        return reduceInt(ast);
    }
    // Handle bool
    if (type.name === "Bool") {
        return reduceBool(ast);
    }
    // Handle string
    if (type.name === "String") {
        return reduceString(ast);
    }
    // Handle Address
    if (type.name === "Address") {
        return reduceAddress(ast, ctx);
    }
    // Handle Cell
    if (type.name === "Cell") {
        return reduceCell(ast);
    }
    (0, ast_1.throwError)(`Expected constant value, got ${(0, types_1.printTypeRef)(type)}`, ast.ref);
}
exports.resolveConstantValue = resolveConstantValue;
