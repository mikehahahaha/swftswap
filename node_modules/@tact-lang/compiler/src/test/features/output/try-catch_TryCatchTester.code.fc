#pragma version =0.4.4;
#pragma allow-post-modification;
#pragma compute-asm-ltr;

#include "try-catch_TryCatchTester.headers.fc";
#include "try-catch_TryCatchTester.stdlib.fc";
#include "try-catch_TryCatchTester.constants.fc";
#include "try-catch_TryCatchTester.storage.fc";

;;
;; Contract TryCatchTester functions
;;

(int) $TryCatchTester$_contract_init() impure inline_ref {
    var (($self'counter)) = (0);
    return ($self'counter);
}

((int), int) $TryCatchTester$_fun_getCounter((int) $self) impure inline_ref {
    var (($self'counter)) = $self;
    return (($self'counter), $self'counter);
}

((int), int) $TryCatchTester$_fun_testTryCatch1((int) $self) impure inline_ref {
    var (($self'counter)) = $self;
    try {
        throw(101);
        return (($self'counter), 42);
    } catch (_) { }
    return (($self'counter), 7);
}

((int), int) $TryCatchTester$_fun_testTryCatch2((int) $self) impure inline_ref {
    var (($self'counter)) = $self;
    try {
        throw(101);
        return (($self'counter), 42);
    } catch (_, $e) {
        return (($self'counter), $e);
    }
}

((int), int) $TryCatchTester$_fun_testTryCatch3((int) $self) impure inline_ref {
    var (($self'counter)) = $self;
    try {
        slice $xs = begin_parse(end_cell(store_uint(begin_cell(), 0, 1)));
        int $x = $xs~load_uint(1);
        try {
            throw(101);
        } catch (_, $e) {
            return (($self'counter), ($e / $x));
        }
        int $e = 123;
        return (($self'counter), $e);
    } catch (_, $e) {
        return (($self'counter), $e);
    }
}

;;
;; Receivers of a Contract TryCatchTester
;;

(((int)), ()) %$TryCatchTester$_internal_empty((int) $self) impure inline {
    var ($self'counter) = $self;
    return (($self'counter), ());
}

((int), ()) $TryCatchTester$_internal_text_c4f8d72312edfdef5b7bec7833bdbb162d1511bd78a912aed0f2637af65572ae((int) $self) impure inline {
    var ($self'counter) = $self;
    $self'counter = $self'counter + 1;
    return (($self'counter), ());
}

((int), ()) $TryCatchTester$_internal_text_d2fc2655ae84e1547b9e18a3e02ce0dd41c64b128a4742624788458ad4fad2a2((int) $self) impure inline {
    var ($self'counter) = $self;
    try {
        $self'counter = $self'counter + 1;
        throw(123);
    } catch (_) { }
    return (($self'counter), ());
}

((int), ()) $TryCatchTester$_internal_text_bf0f14cf181c6161e827bfda5129fdd7ec447514bc4c98d87bd4477044a0d60b((int) $self) impure inline {
    var ($self'counter) = $self;
    $self'counter = $self'counter + 1;
    ($self'counter)~$TryCatchTester$_fun_reply(__gen_cell_comment_dfa8f99304efb161bde3465269e1126e4aa33b5c430fd95a7b0cca0fd35b8a4b());
    try {
        $self'counter = $self'counter + 1;
        ($self'counter)~$TryCatchTester$_fun_reply(__gen_cell_comment_0879cf11eb0469580643e0337e0749fe3f969b7c3e82ccd5bbefd073d257bf5d());
        $global_emit(__gen_cell_comment_ec65c74747db20896a39d874b0473dd5e61e08fc9f3516d56d58eaeea5031ea4());
        throw(123);
    } catch (_) { }
    return (($self'counter), ());
}

;;
;; Get methods of a Contract TryCatchTester
;;

_ %getCounter() method_id(103307) {
    var self = $TryCatchTester$_contract_load();
    var res = self~$TryCatchTester$_fun_getCounter();
    return res;
}

_ %testTryCatch1() method_id(102848) {
    var self = $TryCatchTester$_contract_load();
    var res = self~$TryCatchTester$_fun_testTryCatch1();
    return res;
}

_ %testTryCatch2() method_id(106915) {
    var self = $TryCatchTester$_contract_load();
    var res = self~$TryCatchTester$_fun_testTryCatch2();
    return res;
}

_ %testTryCatch3() method_id(110978) {
    var self = $TryCatchTester$_contract_load();
    var res = self~$TryCatchTester$_fun_testTryCatch3();
    return res;
}

_ supported_interfaces() method_id {
    return (
        "org.ton.introspection.v0"H >> 128,
        "org.ton.abi.ipfs.v0"H >> 128,
        "org.ton.deploy.lazy.v0"H >> 128,
        "org.ton.chain.workchain.v0"H >> 128
    );
}

_ get_abi_ipfs() method_id {
    return "ipfs://QmcxT6K8vZGyG3HKrX4BEvCDSPFSg23hMnQu7ME9HZoCcn";
}

_ lazy_deployment_completed() method_id {
    return get_data().begin_parse().load_int(1);
}

;;
;; Routing of a Contract TryCatchTester
;;

((int), int) $TryCatchTester$_contract_router_internal((int) self, int msg_bounced, slice in_msg) impure inline_ref {
    ;; Handle bounced messages
    if (msg_bounced) {
        return (self, true);
    }
    
    ;; Parse incoming message
    int op = 0;
    if (slice_bits(in_msg) >= 32) {
        op = in_msg.preload_uint(32);
    }
    
    
    ;; Receive empty message
    if ((op == 0) & (slice_bits(in_msg) <= 32)) {
        self~%$TryCatchTester$_internal_empty();
        return (self, true);
    }
    
    ;; Text Receivers
    if (op == 0) {
        var text_op = slice_hash(in_msg);
        
        ;; Receive "increment" message
        if (text_op == 0xc4f8d72312edfdef5b7bec7833bdbb162d1511bd78a912aed0f2637af65572ae) {
            self~$TryCatchTester$_internal_text_c4f8d72312edfdef5b7bec7833bdbb162d1511bd78a912aed0f2637af65572ae();
            return (self, true);
        }
        
        ;; Receive "incrementTryCatch" message
        if (text_op == 0xd2fc2655ae84e1547b9e18a3e02ce0dd41c64b128a4742624788458ad4fad2a2) {
            self~$TryCatchTester$_internal_text_d2fc2655ae84e1547b9e18a3e02ce0dd41c64b128a4742624788458ad4fad2a2();
            return (self, true);
        }
        
        ;; Receive "tryCatchRegisters" message
        if (text_op == 0xbf0f14cf181c6161e827bfda5129fdd7ec447514bc4c98d87bd4477044a0d60b) {
            self~$TryCatchTester$_internal_text_bf0f14cf181c6161e827bfda5129fdd7ec447514bc4c98d87bd4477044a0d60b();
            return (self, true);
        }
    }
    
    return (self, false);
}

() recv_internal(int msg_value, cell in_msg_cell, slice in_msg) impure {
    
    ;; Context
    var cs = in_msg_cell.begin_parse();
    var msg_flags = cs~load_uint(4);
    var msg_bounced = -(msg_flags & 1);
    slice msg_sender_addr = __tact_verify_address(cs~load_msg_addr());
    __tact_context = (msg_bounced, msg_sender_addr, msg_value, cs);
    __tact_context_sender = msg_sender_addr;
    
    ;; Load contract data
    var self = $TryCatchTester$_contract_load();
    
    ;; Handle operation
    int handled = self~$TryCatchTester$_contract_router_internal(msg_bounced, in_msg);
    
    ;; Throw if not handled
    throw_unless(130, handled);
    
    ;; Persist state
    $TryCatchTester$_contract_store(self);
}
