;;
;; Type: MyStruct
;; TLB: _ a:int257 b:bool = MyStruct
;;

builder $MyStruct$_store(builder build_0, (int, int) v) inline {
    var (v'a, v'b) = v;
    build_0 = build_0.store_int(v'a, 257);
    build_0 = build_0.store_int(v'b, 1);
    return build_0;
}

cell $MyStruct$_store_cell((int, int) v) inline {
    return $MyStruct$_store(begin_cell(), v).end_cell();
}

(slice, ((int, int))) $MyStruct$_load(slice sc_0) inline {
    var v'a = sc_0~load_int(257);
    var v'b = sc_0~load_int(1);
    return (sc_0, (v'a, v'b));
}

tuple $MyStruct$_as_optional((int, int) v) inline {
    var (v'a, v'b) = v;
    return __tact_tuple_create_2(v'a, v'b);
}

tuple $MyStruct$_load_opt(cell cl) inline {
    if (null?(cl)) {
        return null();
    }
    var sc = cl.begin_parse();
    return $MyStruct$_as_optional(sc~$MyStruct$_load());
}

((int, int)) $MyStruct$_not_null(tuple v) inline {
    throw_if(128, null?(v));
    var (int vvv'a, int vvv'b) = __tact_tuple_destroy_2(v);
    return (vvv'a, vvv'b);
}

((int, int)) $MyStruct$_constructor_a_b(int a, int b) inline {
    return (a, b);
}

;;
;; Type: MapTraverseTestContract
;;

tuple $MapTraverseTestContract$_contract_load() impure inline_ref {
    slice $sc = get_data().begin_parse();
    __tact_context_sys = $sc~load_ref();
    int $loaded = $sc~load_int(1);
    if ($loaded) {
        return null();
    } else {
        ;; Allow only workchain deployments
        throw_unless(137, my_address().preload_uint(11) == 1024);
        return $MapTraverseTestContract$_contract_init();
    }
}

() $MapTraverseTestContract$_contract_store(tuple v) impure inline {
    builder b = begin_cell();
    b = b.store_ref(__tact_context_sys);
    b = b.store_int(true, 1);
    set_data(b.end_cell());
}